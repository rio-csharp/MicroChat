@using MicroChat.Client.Models
@using MicroChat.Client.Services
@using MicroChat.Client.Components
@using System.Text
@using Microsoft.JSInterop
@inject ConversationService ConversationService
@inject ChatService ChatService
@inject IJSRuntime JSRuntime
@implements IDisposable

@if (ConversationService.SelectedConversation != null)
{
    <div class="chat-panel">
        <div class="chat-messages" id="chat-messages-container">
            @foreach (var message in ConversationService.SelectedConversation.Messages)
            {
                <MessageItem Message="@message" />
            }
            @if (_isStreaming && _streamingContent.Length > 0)
            {
                <MessageItem Message="@_streamingMessage" Content="@_streamingContent.ToString()" IsStreaming="true" />
            }
        </div>
        
        @if (!_isAtBottom && !_isAtTop)
        {
            <button class="scroll-button scroll-to-bottom" @onclick="ScrollToBottomAsync" title="跳转到最新消息">
                <span class="arrow-down">↓</span>
            </button>
            
            <button class="scroll-button scroll-to-top" @onclick="ScrollToTopAsync" title="跳转到最早消息">
                <span class="arrow-up">↑</span>
            </button>
        }
        
        <ChatInput IsStreaming="@_isStreaming" OnSendMessage="SendMessageAsync" />
    </div>
}
else
{
    <div class="chat-panel-empty">
        <h3>请从左侧选择一个聊天</h3>
    </div>
}

@code {
    private bool _isStreaming = false;
    private readonly StringBuilder _streamingContent = new();
    private CancellationTokenSource? _cts;
    private Message _streamingMessage = new() 
    { 
        Sender = MessageRole.Assistant, 
        Time = DateTime.Now,
        Content = string.Empty
    };
    private IJSObjectReference? _jsModule;
    private DotNetObjectReference<ChatPanel>? _dotNetHelper;
    private bool _isAtBottom = true;
    private bool _isAtTop = true;

    protected override void OnInitialized()
    {
        ConversationService.OnChange += StateHasChanged;
    }
    
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && ConversationService.SelectedConversation != null)
        {
            _jsModule = await JSRuntime.InvokeAsync<IJSObjectReference>("import", "./Pages/ChatPanel.razor.js");
            _dotNetHelper = DotNetObjectReference.Create(this);
            await Task.Delay(50);
            await _jsModule.InvokeVoidAsync("init", _dotNetHelper);
            await ScrollToBottomAsync();
        }
    }
    
    [JSInvokable]
    public void UpdateButtonState(bool isAtBottom, bool isAtTop)
    {
        if (_isAtBottom != isAtBottom || _isAtTop != isAtTop)
        {
            _isAtBottom = isAtBottom;
            _isAtTop = isAtTop;
            StateHasChanged();
        }
    }

    private async Task SendMessageAsync(string userMessage)
    {
        if (ConversationService.SelectedConversation == null || string.IsNullOrWhiteSpace(userMessage))
            return;

        await AddUserMessageAsync(userMessage);
        await ProcessAiResponseAsync(userMessage);
    }

    private async Task AddUserMessageAsync(string userMessage)
    {
        var userMsg = new Message
        {
            Sender = MessageRole.User,
            Content = userMessage,
            Time = DateTime.Now,
            Model = ConversationService.SelectedConversation!.AIModel
        };
        ConversationService.SelectedConversation.Messages.Add(userMsg);
        await ConversationService.UpdateConversationAsync(ConversationService.SelectedConversation);
    }

    private async Task ProcessAiResponseAsync(string userMessage)
    {
        _isStreaming = true;
        _streamingContent.Clear();
        _cts = new CancellationTokenSource();
        
        try
        {
            await StreamAiResponseAsync(userMessage);
            await SaveAssistantMessageAsync();
        }
        catch (OperationCanceledException)
        {
            // 用户取消了请求
        }
        catch (Exception ex)
        {
            await AddErrorMessageAsync(ex.Message);
        }
        finally
        {
            ResetStreamingState();
        }
    }

    private async Task StreamAiResponseAsync(string userMessage)
    {
        await foreach (var chunk in ChatService.SendMessageStreamAsync(
            ConversationService.SelectedConversation!, 
            userMessage, 
            _cts!.Token))
        {
            _streamingContent.Append(chunk);
            StateHasChanged();
            await ScrollToBottomAsync();
        }
    }

    private async Task SaveAssistantMessageAsync()
    {
        if (_streamingContent.Length == 0)
            return;

        var assistantMsg = new Message
        {
            Sender = MessageRole.Assistant,
            Content = _streamingContent.ToString(),
            Time = DateTime.Now,
            Model = ConversationService.SelectedConversation!.AIModel
        };
        ConversationService.SelectedConversation.Messages.Add(assistantMsg);
        await ConversationService.UpdateConversationAsync(ConversationService.SelectedConversation);
    }

    private async Task AddErrorMessageAsync(string errorMessage)
    {
        var errorMsg = new Message
        {
            Sender = MessageRole.Assistant,
            Content = $"发送失败: {errorMessage}",
            Time = DateTime.Now,
            Model = ConversationService.SelectedConversation!.AIModel
        };
        ConversationService.SelectedConversation.Messages.Add(errorMsg);
        await ConversationService.UpdateConversationAsync(ConversationService.SelectedConversation);
    }

    private void ResetStreamingState()
    {
        _isStreaming = false;
        _streamingContent.Clear();
        _cts?.Dispose();
        _cts = null;
        StateHasChanged();
    }

    private async Task ScrollToBottomAsync()
    {
        if (_jsModule != null)
        {
            await _jsModule.InvokeVoidAsync("scrollToBottom");
        }
    }
    
    private async Task ScrollToTopAsync()
    {
        if (_jsModule != null)
        {
            await _jsModule.InvokeVoidAsync("scrollToTop");
        }
    }

    public void Dispose()
    {
        ConversationService.OnChange -= StateHasChanged;
        _cts?.Cancel();
        _cts?.Dispose();
        _dotNetHelper?.Dispose();
        _jsModule?.DisposeAsync();
    }
}
