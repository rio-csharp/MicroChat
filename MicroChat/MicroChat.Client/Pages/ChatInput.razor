@using MicroChat.Client.Models
@inject IJSRuntime JSRuntime

<div class="chat-input-area">
    <div class="input-wrapper">
        <textarea @ref="_textArea"
                  @bind="_inputMessage"
                  @bind:event="oninput"
                  @bind:after="AdjustTextAreaHeight"
                  @onkeydown="HandleKeyDown"
                  placeholder="输入消息..."
                  disabled="@IsStreaming"
                  rows="1"></textarea>
        <button class="send-button" @onclick="SendMessage" @disabled="@(IsStreaming || string.IsNullOrWhiteSpace(_inputMessage))" title="@(IsStreaming ? "发送中..." : "发送")">
            @if (IsStreaming)
            {
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none">
                    <circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="2"/>
                </svg>
            }
            else
            {
                <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"/>
                </svg>
            }
        </button>
    </div>
</div>

@code {
    private ElementReference _textArea;
    private string _inputMessage = string.Empty;

    [Parameter]
    public bool IsStreaming { get; set; }

    [Parameter]
    public EventCallback<string> OnSendMessage { get; set; }

    private async Task HandleKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Enter" && !e.ShiftKey && !IsStreaming && !string.IsNullOrWhiteSpace(_inputMessage))
        {
            await SendMessage();
        }
    }

    private async Task SendMessage()
    {
        if (!string.IsNullOrWhiteSpace(_inputMessage))
        {
            var message = _inputMessage.Trim();
            _inputMessage = string.Empty;
            await OnSendMessage.InvokeAsync(message);
            await ResetTextAreaHeight();
        }
    }

    private async Task AdjustTextAreaHeight()
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("eval", @"
                const textarea = document.querySelector('.chat-input-area textarea');
                if (textarea) {
                    textarea.style.height = 'auto';
                    const scrollHeight = textarea.scrollHeight;
                    if (scrollHeight > 200) {
                        textarea.style.height = '200px';
                        textarea.classList.add('scrollable');
                    } else {
                        textarea.style.height = scrollHeight + 'px';
                        textarea.classList.remove('scrollable');
                    }
                }
            ");
        }
        catch { }
    }

    private async Task ResetTextAreaHeight()
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("eval", @"
                const textarea = document.querySelector('.chat-input-area textarea');
                if (textarea) {
                    textarea.style.height = '36px';
                    textarea.classList.remove('scrollable');
                }
            ");
        }
        catch { }
    }
}
